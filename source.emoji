jmp $main$

exception:
$EXCEPTION, halting...
$.0

$FUNCTION finput() -> (:8)
finput:
    // Take the first letter of the input and store it at :8
    in :8
    jf (:7 = :8 == .10) $finput.flush$
    ret

    finput.flush:
        // Flush input
        in :7
        jf (:7 = :7 == .10) $finput.flush$
        ret

$FUNCTION fprint(:8) -> ()
fprint:
    // Print every character starting at :8 and stopping at \0
    // (first char is assumed not to be null)
    rmem :7 :8

    fprint.loop:
        out :7
        :8 += .1
        rmem :7 :8
        jt :7 $fprint.loop$

    ret

$FUNCTION fprint_stack() -> ()
fprint_stack:
    // Print the stack until \0
    // (first char is assumed not to be null)
    pop :7
    pop :8

    fprint_stack.loop:
        out :8
        pop :8
        jt :8 $fprint_stack.loop$

    push :7
    ret

$FUNCTION fprint_number(:8) -> ()
fprint_number:
    // Print number stored in :8 as a string
    push .0
    wmem $fprint_number.unit$ .1
    wmem $fprint_number.number$ :8
    :7 = .1

    fprint_number.loop:
        :6 = :7 * .10
        wmem $fprint_number.unit$ :6
        :8 %= :6
        :6 = .0
        :4 = :7

        fprint_number.loop.loop:
            jt (:5 = :7 > :8) $fprint_number.loop.continue$
            :6 += .1
            :7 += :4
            jmp $fprint_number.loop.loop$

        fprint_number.loop.continue:
            :6 += 0
            push :6
            rmem :7 $fprint_number.unit$
            rmem :8 $fprint_number.number$
            jf (:6 = :7 > :8) $fprint_number.loop$

            $fprint_stack$()
            ret

    fprint_number.unit: $.1
    fprint_number.number: $.0

$SUBROUTINE GameOfLife
gol:
    $fprint$(:8 = $gol.init$)
    jmp $gol.loop$

    gol.init:
        $0. Exit
        $Enter -> Next grid state
        $.0
    gol.invalid:
        $Invalid option, choose another one!
        $.0
    gol.board0:
        $###             .
    gol.board1:
        $0000111122223333.
    gol.board:
        {$gol.board0$$gol.board1$

    gol.loop:
        $finput$()

        jt (:7 = :8 == 0) $main$
        jf (:7 = :8 == .10) $gol.loop.invalid$

        print board0 .10
        $gol.fprint_board$()
        $gol.fswap_boards$()
        print board1 .10
        $gol.fprint_board$()
        $gol.fswap_boards$()
        
        $gol.fnext$()
        $gol.fswap_boards$()

        jmp $gol.loop$

        gol.loop.invalid:
            $fprint$(:8 = $gol.invalid$)
            jmp $gol.loop$

    $FUNCTION gol.fnext() -> ()
    gol.fnext:
        // Determines the next board based on the actual one
        //  and Conway's Game of Life rules
        :8 = $gol.board$
        rmem :7 :8
        :8 += .1
        rmem :8 :8
        :1 = .0

        gol.fnext.loop:
            $gol.fget_neighbours$()
            :4 = :7 + :1
            :6 = :8 + :1
            rmem :4 :4

            jt (:3 = :2 == .3) $gol.fnext.loop.on$
            :3 = :2 == .2
            :4 = :4 == #
            jt (:3 = :3 & :4) $gol.fnext.loop.on$

            wmem :6 .32
            jmp $gol.fnext.loop.continue$

            gol.fnext.loop.on:
            wmem :6 #

            gol.fnext.loop.continue:
            :1 += .1
            jt (:6 = .16 > :1) $gol.fnext.loop$

        ret

    $FUNCTION gol.fget_neighbours(:1) -> (:2)
    gol.fget_neighbours:
        // column :1, row :2
        // Get number of neighbours
        :6 = $gol.board$
        rmem :6 :6
        :2 = .0

        :4 = ~.4
        :5 = ~.1

        // NW
        :3 = :1 + :4
        :3 += :5
        :3 %= .16
        $fprint_number$(:8 = :3)
        out :
        :3 += :6
        rmem :3 :3
        :3 = :3 == #
        :2 += :3

        // N
        :3 = :1 + :4
        $fprint_number$(:8 = :3)
        out :
        :3 += :6
        rmem :3 :3
        :3 = :3 == #
        :2 += :3

        // NE
        :3 = :1 + :4
        :3 += .1
        :3 %= .16
        $fprint_number$(:8 = :3)
        out :
        :3 += :6
        rmem :3 :3
        :3 = :3 == #
        :2 += :3

        //W
        :3 = :1 + :5
        :3 %= .16
        $fprint_number$(:8 = :3)
        out :
        :3 += :6
        rmem :3 :3
        :3 = :3 == #
        :2 += :3

        //E
        :3 = :1 + .1
        :3 %= .16
        $fprint_number$(:8 = :3)
        out :
        :3 += :6
        rmem :3 :3
        :3 = :3 == #
        :2 += :3

        // SW
        :3 = :1 + .4
        :3 += :5
        :3 %= .16
        $fprint_number$(:8 = :3)
        out :
        :3 += :6
        rmem :3 :3
        :3 = :3 == #
        :2 += :3

        // S
        :3 = :1 + .4
        :3 %= .16
        $fprint_number$(:8 = :3)
        out :
        :3 += :6
        rmem :3 :3
        :3 = :3 == #
        :2 += :3

        // SE
        :3 = :1 + .4
        :3 += .1
        :3 %= .16
        $fprint_number$(:8 = :3)
        out :
        :3 += :6
        rmem :3 :3
        :3 = :3 == #
        :2 += :3

        :6 = :8
        $fprint_number$(:8 = :1)
        print ->
        $fprint_number$(:8 = :2)
        out ,
        :8 = :6
        ret

    $FUNCTION gol.fswap_boards() -> ()
    gol.fswap_boards:
        // Swap the pointers in gol.board
        :8 = $gol.board$
        rmem :7 :8
        :5 = :8 + .1
        rmem :6 :5
        wmem :8 :6
        wmem :5 :7

        ret

    $FUNCTION gol.fprint_board() -> ()
    gol.fprint_board:
        // Print gol.board as a grid
        :8 = $gol.board$
        rmem :8 :8
        :5 = .0

        gol.fprint_board.loop:
            :6 = .0

            gol.fprint_board.loop.loop:
                rmem :7 :8
                out :7
                :6 += .1
                :8 += .1
                jt (:7 = .4 > :6) $gol.fprint_board.loop.loop$
                out .10

            :5 += .1
            jt (:7 = .4 > :5) $gol.fprint_board.loop$

        ret

$SUBROUTINE RockPaperScissors
rps:
    $fprint$(:8 = $rps.init$)
    jmp $rps.loop$

    rps.game0: $.0
    rps.last_winner: $.0
    rps.count.tie: $.0
    rps.count.pc: $.0
    rps.count.human: $.0
    rps.count:
        {$rps.count.tie$$rps.count.pc$$rps.count.human$
    rps.option.rock: $ROCK.0
    rps.option.paper: $PAPER.0
    rps.option.scissors: $SCISSORS.0
    rps.option:
        {$rps.option.rock$$rps.option.paper$$rps.option.scissors$
    rps.win.tie: $It's a tie!.0
    rps.win.pc: $PC wins.0
    rps.win.human: $HUMAN wins.0
    rps.win:
        {$rps.win.tie$$rps.win.pc$$rps.win.human$
    rps.init:
        $0. Exit
        $1. Rock
        $2. Paper
        $3. Scissors
        $.0
    rps.invalid:
        $Invalid option, choose another one!
        $.0

    rps.loop:
        out >
        $finput$()

        jt (:7 = :8 == 0) $main$
        jt (:7 = 0 > :8) $rps.loop.invalid$
        jt (:7 = :8 > 3) $rps.loop.invalid$

        $rps.fai$()
        :2 = :8 % 1

        $rps.fprint_move$(:8 = :1)
        print .32 vs .32
        $rps.fprint_move$(:8 = :2)
        out .10

        $rps.fwinner$()
        wmem $rps.game0$ :2

        jmp $rps.loop$

        rps.loop.invalid:
            $fprint$(:8 = $rps.invalid$)
            jmp $rps.loop$


    $FUNCTION rps.fwinner(:1, :2) -> ()
    rps.fwinner:
        // Choose a winner based on both moves

        :3 = ~:2
        :3 += :1
        :3 += .1
        :3 %= .3

        :8 = :3 + $rps.win$
        rmem :8 :8
        $fprint$()
        wmem $rps.last_winner$ :3

        print .32 (
        :8 = :3 + $rps.count$
        rmem :8 :8
        rmem :7 :8
        :6 = :7 + .1
        wmem :8 :6
        $fprint_number$(:8 = :7)
        print .32 times) .10

        ret

    $FUNCTION rps.ai() -> (:1)
    rps.fai:
        // Choose a move based on previous moves and result
        rmem :1 $rps.game0$
        rmem :2 $rps.last_winner$
        :1 += .1
        :2 = :2 == .1
        :1 += :2
        :1 %= .3

        ret

    $FUNCTION rps.fprint_move(:8) -> ()
    rps.fprint_move:
        // Prints ROCK, PAPER or SCISSORS dending on the value of :8
        :8 += $rps.option$
        rmem :8 :8
        $fprint$()
        ret

$Main
main:
    $fprint$(:8 = $main.init$)

    main.loop:
        $finput$()

        jt (:7 = :8 == 0) $main.exit$
        jt (:7 = :8 == 1) $gol$  // GameOfLife
        jt (:7 = :8 == 2) $rps$  // RockPaperScissors

        $fprint$(:8 = $main.invalid$)
        jmp $main.loop$

    main.exit:
        $fprint$(:8 = $main.end$)
        halt

    main.init:
        $Hello and welcome to my bowl of Spaghetti!
        $What program do you want to load?
        $0. Exit
        $1. Game of Life
        $2. Rock Paper Scissors
        $>.0
    main.invalid:
        $Invalid option, choose another one!
        $>.0
    main.end:
        $I really enjoyed this time spent with you.
        $Come back soon!
        $.0

